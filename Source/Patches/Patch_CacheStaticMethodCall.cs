using RimThreaded.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;
using HarmonyLib;
using JetBrains.Annotations;
using RimThreaded.Patching;
using UnityEngine.Assertions;
using Verse;

namespace RimThreaded.Patches;

// While System.Runtime.Caching.MemoryCache is a bit expensive per entry, its awareness of cache-specific or application-wide memory limits will
// help avoid flooding/stalling memory with cached method results.
// TODO: How to handle or ignore methods with side effects.
[HarmonyPatch]
public static class Patch_CacheStaticMethodCall
{
    private static readonly MemoryCache ResultCache = new(nameof(Patch_CacheStaticMethodCall));

    private static readonly CacheItemPolicy ItemPolicy = new()
    {
        UpdateCallback = CacheEntryUpdateCallback
    };

    private static readonly Dictionary<MethodBase, int> MethodEvictions = new();
    private static readonly Dictionary<int, int> EntryCreationTicks = new();

    private static void CacheEntryUpdateCallback(CacheEntryUpdateArguments arguments)
    {
        // Untrack before removal, prevents using tracking data when result cache is unaligned
        var identity = int.Parse(arguments.Key);
        _ = EntryCreationTicks.Remove(identity);
    }


    [HarmonyPrepare]
    public static void Prepare(Harmony harmony, MethodBase original = null)
    {
        if (original is null)
        {
            ItemPolicy.SlidingExpiration = TimeSpan.FromMilliseconds(RimThreadedSettings.Instance.TimeoutMilliseconds);
        }

        if (original is not null)
        {
            if (MethodEvictions.ContainsKey(original))
            {
                throw new ArgumentException($"Method {original} is already handled", nameof(original));
            }

            if (!original.IsStatic)
            {
                throw new ArgumentException($"Cannot cache results from non-static method {original}",
                    nameof(original));
            }

            if (original is MethodInfo method)
            {
                if (method.ReturnType == typeof(void))
                {
                    throw new ArgumentException($"Cannot cache results of void returning method {method}", nameof(method));
                }

                if (typeof(object).IsAssignableFrom(method.ReturnType) is false)
                {
                    throw new ArgumentException($"Cannot cache results of method {method} returning a non-reference type {method.ReturnType}", nameof(method));
                }
            }

            // TODO: if this ever changes, make sure the value is non-zero and positive
            MethodEvictions[original] = 1;
        }
    }
    
    [HarmonyTargetMethods]
    public static IEnumerable<MethodBase> TargetMethods(Harmony harmony)
    {
        // TODO: Only target methods that could benefit from caching.
        // TODO: Declare a list of methods to be targeted, possibly as MemberNotation 
        throw new NotImplementedException();
    }

    /// <summary>
    /// Get cached result and cancel original method, or do nothing and let it run.
    /// </summary>
    [HarmonyPrefix]
    public static bool Prefix(ref object __result, object[] __args, MethodBase __originalMethod)
    {
        var identity = MethodCallCacheUtility.GetStaticCallHash(__originalMethod, __args);

        if (ResultCache.Get(identity.ToString()) is { } cacheValue)
        {
            __result = cacheValue;
            return false;
        }

        return true;
    }

    /// <summary>
    /// Cache the result if it was generated by the original method.
    /// </summary>
    [HarmonyPostfix]
    public static void Postfix(ref object __result, object[] __args, MethodBase __originalMethod, bool __runOriginal)
    {
        var identity = MethodCallCacheUtility.GetStaticCallHash(__originalMethod, __args);
        var currentTick = Find.TickManager.TicksGame;

        if (__runOriginal) // Save a full execution in the cache
        {
            ResultCache.Set(identity.ToString(), __result, ItemPolicy);
            EntryCreationTicks[identity] = currentTick;
        }
        else // Check if the entry needs to be evicted
        {
            var eviction = MethodEvictions[__originalMethod];
            var creation = EntryCreationTicks[identity];

            if (creation + eviction <= currentTick)
            {
                _ = ResultCache.Remove(identity.ToString());
                _ = EntryCreationTicks.Remove(identity);
            }
        }
    }

    /// <summary>
    /// Observe exceptions and clear caches to prevent potential causes.
    /// </summary>
    [HarmonyFinalizer]
    public static void Finalizer(Exception __exception, ref object __result, object[] __args,
        MethodBase __originalMethod, bool __runOriginal)
    {
        if (__exception is not null) // Evict the cache entry since it potentially caused an exception
        {
            var identity = MethodCallCacheUtility.GetStaticCallHash(__originalMethod, __args);

            _ = ResultCache.Remove(identity.ToString());
            _ = EntryCreationTicks.Remove(identity);
        }
    }

    [HarmonyCleanup]
    public static void Cleanup(Harmony harmony, MethodBase original = null, Exception ex = null)
    {
    }
}